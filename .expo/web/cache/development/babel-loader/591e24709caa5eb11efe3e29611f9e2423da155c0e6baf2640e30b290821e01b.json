{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport React from 'react';\nimport NativeViewGestureHandler from \"./NativeViewGestureHandler\";\nvar NATIVE_WRAPPER_BIND_BLACKLIST = new Set(['replaceState', 'isMounted']);\nvar NATIVE_WRAPPER_PROPS_FILTER = ['id', 'minPointers', 'enabled', 'waitFor', 'simultaneousHandlers', 'shouldCancelWhenOutside', 'hitSlop', 'onGestureEvent', 'onHandlerStateChange', 'onBegan', 'onFailed', 'onCancelled', 'onActivated', 'onEnded', 'shouldActivateOnStart', 'disallowInterruption', 'onGestureHandlerEvent', 'onGestureHandlerStateChange'];\nexport default function createNativeWrapper(Component) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var ComponentWrapper = function (_React$Component) {\n    _inherits(ComponentWrapper, _React$Component);\n    function ComponentWrapper() {\n      var _getPrototypeOf2;\n      var _this;\n      _classCallCheck(this, ComponentWrapper);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ComponentWrapper)).call.apply(_getPrototypeOf2, [this].concat(args)));\n      _this._refHandler = function (node) {\n        var source = node;\n        while (source != null) {\n          for (var _iterator = Object.getOwnPropertyNames(source), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[typeof Symbol === \"function\" ? Symbol.iterator : \"@@iterator\"]();;) {\n            var _ref;\n            if (_isArray) {\n              if (_i >= _iterator.length) break;\n              _ref = _iterator[_i++];\n            } else {\n              _i = _iterator.next();\n              if (_i.done) break;\n              _ref = _i.value;\n            }\n            var _methodName = _ref;\n            if (!_methodName.startsWith('_') && !_methodName.startsWith('component') && !NATIVE_WRAPPER_BIND_BLACKLIST.has(_methodName) && typeof source[_methodName] === 'function' && _this[_methodName] === undefined) {\n              if (source[_methodName].prototype) {\n                _this[_methodName] = source[_methodName].bind(node);\n              } else {\n                _this[_methodName] = source[_methodName];\n              }\n            }\n          }\n          source = Object.getPrototypeOf(source);\n        }\n      };\n      return _this;\n    }\n    _createClass(ComponentWrapper, [{\n      key: \"render\",\n      value: function render() {\n        const gestureHandlerProps = Object.keys(this.props).reduce((props, key) => {\n          if (NATIVE_WRAPPER_PROPS_FILTER.indexOf(key) !== -1) {\n            props[key] = this.props[key];\n          }\n          return props;\n        }, {\n          ...config\n        });\n        return <NativeViewGestureHandler {...gestureHandlerProps}>\n          <Component {...this.props} ref={this._refHandler} />\n        </NativeViewGestureHandler>;\n      }\n    }]);\n    return ComponentWrapper;\n  }(React.Component);\n  ComponentWrapper.propTypes = {\n    ...Component.propTypes\n  };\n  ComponentWrapper.displayName = Component.displayName || 'ComponentWrapper';\n  return ComponentWrapper;\n}","map":{"version":3,"names":["React","NativeViewGestureHandler","NATIVE_WRAPPER_BIND_BLACKLIST","Set","NATIVE_WRAPPER_PROPS_FILTER","createNativeWrapper","Component","config","arguments","length","undefined","ComponentWrapper","_React$Component","_inherits","_getPrototypeOf2","_this","_classCallCheck","_len","args","Array","_key","_possibleConstructorReturn","_getPrototypeOf","call","apply","concat","_refHandler","node","source","_iterator","Object","getOwnPropertyNames","_isArray","isArray","_i","Symbol","iterator","_ref","next","done","value","methodName","startsWith","has","prototype","bind","getPrototypeOf","_createClass","key","render","gestureHandlerProps","keys","props","reduce","indexOf","propTypes","displayName"],"sources":["/Users/sammerinio/Documents/flight-tracking-app/node_modules/react-native-gesture-handler/createNativeWrapper.js"],"sourcesContent":["import React from 'react';\n\nimport NativeViewGestureHandler from './NativeViewGestureHandler';\n\nconst NATIVE_WRAPPER_BIND_BLACKLIST = new Set(['replaceState', 'isMounted']);\n\n/*\n * This array should consist of:\n *   - All keys in propTypes from NativeGestureHandler\n *     (and all keys in GestureHandlerPropTypes)\n *   - 'onGestureHandlerEvent'\n *   - 'onGestureHandlerStateChange'\n */\nconst NATIVE_WRAPPER_PROPS_FILTER = [\n  'id',\n  'minPointers',\n  'enabled',\n  'waitFor',\n  'simultaneousHandlers',\n  'shouldCancelWhenOutside',\n  'hitSlop',\n  'onGestureEvent',\n  'onHandlerStateChange',\n  'onBegan',\n  'onFailed',\n  'onCancelled',\n  'onActivated',\n  'onEnded',\n  'shouldActivateOnStart',\n  'disallowInterruption',\n  'onGestureHandlerEvent',\n  'onGestureHandlerStateChange',\n];\n\nexport default function createNativeWrapper(Component, config = {}) {\n  class ComponentWrapper extends React.Component {\n    static propTypes = {\n      ...Component.propTypes,\n    };\n\n    static displayName = Component.displayName || 'ComponentWrapper';\n\n    _refHandler = node => {\n      // bind native component's methods\n      let source = node;\n      while (source != null) {\n        for (let methodName of Object.getOwnPropertyNames(source)) {\n          if (\n            !methodName.startsWith('_') && // private methods\n            !methodName.startsWith('component') && // lifecycle methods\n            !NATIVE_WRAPPER_BIND_BLACKLIST.has(methodName) && // other\n            typeof source[methodName] === 'function' &&\n            this[methodName] === undefined\n          ) {\n            if (source[methodName].prototype) {\n              // determine if it's not bound already\n              this[methodName] = source[methodName].bind(node);\n            } else {\n              this[methodName] = source[methodName];\n            }\n          }\n        }\n        source = Object.getPrototypeOf(source);\n      }\n    };\n\n    render() {\n      // filter out props that should be passed to gesture handler wrapper\n      const gestureHandlerProps = Object.keys(this.props).reduce(\n        (props, key) => {\n          if (NATIVE_WRAPPER_PROPS_FILTER.indexOf(key) !== -1) {\n            props[key] = this.props[key];\n          }\n          return props;\n        },\n        { ...config } // watch out not to modify config\n      );\n      return (\n        <NativeViewGestureHandler {...gestureHandlerProps}>\n          <Component {...this.props} ref={this._refHandler} />\n        </NativeViewGestureHandler>\n      );\n    }\n  }\n  return ComponentWrapper;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}